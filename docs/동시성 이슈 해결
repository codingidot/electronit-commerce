✅ 문제 식별
동시성 이슈가 발생할 수 있는 상황은 크게 두 가지로 나뉩니다.

[쿠폰 발급]
선착순으로 쿠폰을 발급받을 경우, 여러 사용자가 동시에 쿠폰을 요청하면 동시성 이슈가 발생할 수 있습니다.

[재고 차감]
주문 시 여러 사용자가 동시에 하나의 상품을 구매하면, 재고 차감 시 동시성 문제가 발생할 수 있습니다.
사용자의 잔액 충전 및 차감은 각 사용자 단위로 이루어지기 때문에 상대적으로 문제가 적습니다. 
충전하거나 주문으로 인해 잔액이 차감될 때는 프론트엔드에서 버퍼링 처리(중복 요청 방지)를 통해 연속적인 요청을 막을 수 있습니다.

하지만 쿠폰 발급과 재고 차감은 모든 사용자가 공유하는 자원으로, 다수의 트랜잭션이 동시에 같은 데이터를 update하려고 하기 때문에 동시성 문제가 더욱 빈번하게 발생합니다. 그리고 다른 사용자의 update를 프론트엔드에서 제어하거나 지연시키는 것도 불가능하기 때문에, 위 두 경우가 가장 큰 문제라고 판단했습니다.

✅ 분석
ERD 파일은 /docs/ERD 폴더에 이커머스ERD_20250807.png 참고바랍니다

1) 쿠폰 발급
처음에는 사용자가 쿠폰을 발급받을 때, coupon_issue 테이블에서 coupon_id에 해당하는 row 개수를 조회하여 발급된 쿠폰 수를 확인하려고 했습니다.
하지만 여러 사용자가 동시에 조회를 시도하면 모두 동일한 값을 읽게 됩니다. 기존에 존재하는 row에는 락을 걸 수 있지만, insert된 row 수를 기준으로 count하는 경우에는 락을 걸 수 없습니다.

따라서 이를 해결하기 위해, 쿠폰 테이블(coupon)에 발급된 쿠폰 수를 저장하는 컬럼(issued_count)을 추가하여 이를 기준으로 처리하도록 변경하였습니다.

2) 재고 차감
재고는 관리자가 수동으로 차감할 수도 있지만, 대부분 주문을 통해 자동으로 재고가 차감됩니다.
따라서 동시성 문제가 발생할 가능성이 가장 높은 부분은 여러 주문이 동시에 들어와 재고가 차감되는 상황입니다. 이 부분에서 동시성 제어가 반드시 필요하다고 판단하였습니다.

✅ 해결 방안
1) 쿠폰 발급
처음에는 비관적 락(Pessimistic Lock) 을 이용하여 동시성 제어를 하였습니다.
쿠폰을 조회할 때 비관적 락을 적용하면, 다른 트랜잭션이 해당 coupon_id에 대한 데이터를 조회할 때 락이 걸려 대기하게 됩니다.
이는 serializable 수준의 안정성을 제공하지만, 동시에 많은 트랜잭션이 발생하는 선착순 쿠폰 발급에서는 성능 저하가 심각할 수 있다고 판단했습니다.

그래서 방식은 낙관적 락(Optimistic Lock) 으로 전환하였습니다.
낙관적 락은 트랜잭션을 시작할 때 락을 걸지 않기 때문에 동시에 많은 요청을 처리할 수 있습니다. @Version 어노테이션을 적용하여 엔티티의 버전을 관리하며, 커밋 시 버전 충돌이 발생하면 ObjectOptimisticLockingFailureException 예외가 발생합니다.

단점은 동시 요청이 많으면 에러가 빈번히 발생한다는 점인데, 이 경우를 대비하여 최대 5회까지 재시도할 수 있도록 구현하였습니다.
낙관적 락 예외는 트랜잭션이 커밋될 때 발생하므로, 해당 예외를 처리하려면 @Transactional이 적용된 메서드 외부에서 try-catch로 감싸야 합니다.

그래서 저는 withTransaction() 메서드를 별도로 만들어 @Transactional을 적용하고, 이 메서드를 try-catch로 감싸 재시도 로직을 구성했습니다.

쿠폰발급 비관적 락 : 30d5fab877aef88b1fe24d148813eeadd85b9ae9
쿠폰발급 낙관적 락 : d73ebc7d294e7f44374657a72d86871ecf2fa6fc
쿠폰발급 동시성 테스트 : 447cf2114646ff17940236e3bc09249bf6360586

2) 재고 차감
재고 차감 로직도 쿠폰 발급과 마찬가지로 낙관적 락을 적용해 동시성 문제를 해결했습니다.
낙관적 락 충돌 시 최대 5회까지 재시도하도록 구성했습니다.

초기에는 재고 차감 로직을 별도의 트랜잭션으로 분리해서 처리하려 했지만, 그렇게 하면 주문이 실패했음에도 재고는 차감되는 문제가 발생할 수 있습니다.

따라서 재고 차감은 주문 트랜잭션 안에서 함께 처리되도록 구성하였고, 전체 주문 로직을 withTransaction() 메서드로 묶어 try-catch로 감싸 재시도할 수 있도록 구현했습니다.

재고차감 낙관적 락 : 42bcc2b8199fa32499e29b252b2a1ad2b178fcad
재고차감 동시성 테스트 : 7ad36e6b01960c2838ef64cadea6a68041881a10


