성능 계선을 위한 인덱스
- coupon_issue 테이블의 (user_id, coupon_id) 
이유 : user_id와 coupon_id는 user테이블, coupon 테이블과 같이 조인해서 사용할 수 있고, 사용자의 쿠폰발급 여부를 알기위해 두가지 조건으로 조회를 한다. user_id가 선택도가 높아 앞으로 선정했다.

- coupon_issue 테이블의 (coupon_id)
이유 : 쿠폰마다 선착순으로 발급을 받는데 현재 몇개가 발급됐는지 확인하기 위해서 쿠폰아이디로 발급된 수를 조회해야한다.
(user_id, coupon_id) 복합 인덱스는 user_id 순서로 먼저 정렬되어 있기에 인덱스 효과를 기대하지 못한다. 그래서 (coupon_id)의 별도 인덱스를 생성한다. 일단 기본적으로 user테이블과 coupon테이블이 매핑되는 테이블이라 데이터가 수가 많은 테이블이기에 인덱스가 필요하닥 판단했다.

- order 테이블의 (order_date, user_id), (order_date, goods_id)
이유 : order 테이블은 가장 데이터가 많이 쌓이는 테이블로 기본적으로 주문 조회 화면에는 날짜 범위를 선택하도록 설계하는게 좋을 것 같다. 날짜 컬럼을 인덱스 앞에 두어 선택한 날짜 범위의 사용자 및 상품의 결과를 빠르게 조회할 수 있다.

- order 테이블의 (user_id), (goods_id), (coupon_id) 
이유 : order 테이블과 조인하는 컬럼들로 조인을 빠르게 수행 할 있다.


모든 테이블의 pk를 LONG 타입으로 설정
이유 : 
- PK를 연속된 숫자로하면 인덱스 정렬이 수월
- UUID에 비해 메모리 낭비가 적다. LONG은 8바이트로 네트워크 전송/직렬화 시 효율적이다.
- 순차적으로 들어가기에 직관적이다.
- JPA 등으로 쉽게 자동 증가 할 수 있다.