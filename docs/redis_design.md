
# STEP 13. Ranking Design

🎯 **목표**  
최근 3일간 가장 많이 주문된 상품의 랭킹을 Redis 기반으로 구현한다.

---

🛠 **설계**  

**데이터 구조:**  
- Redis Sorted Set(ZSet)을 이용하여 `product:rank:날짜` 키에 상품별 주문 수를 저장.  
- ZSet은 `score`(상품 주문 수)와 `member`(상품 ID)를 기반으로 정렬 가능하여 랭킹에 적합하다.  

**집계 로직:**  
- 최근 3일치 데이터를 `ZUNIONSTORE`를 이용해 합산 → `product:rank:3days:tmp` 키에 저장.  
- TTL(Time To Live)을 10분 부여하여 캐시 재활용 및 Redis 부하 방지.  
- 요청 시 캐시에 결과가 존재하면 즉시 반환, 없으면 새로 계산.  

---

✅ **회고**  

**장점**  
- Redis Sorted Set을 활용해 순위 계산을 빠르게 처리할 수 있음.  
- TTL을 통해 캐시 갱신 주기를 관리하여 성능 최적화 가능.  

**한계/개선점**  
- 단순히 "주문 수"만 기준으로 랭킹을 매김 → 매출액, 사용자 수 등 다양한 기준 고려 필요.  
- TTL 만료 시 순간적으로 캐시 미스 발생 → 백업 작업자(배치)로 미리 갱신하는 Pre-warm 전략 고려 가능.  

---

# STEP 14. Asynchronous Design (선착순 쿠폰 발급)

🎯 **목표**  
한정된 수량의 쿠폰을 선착순으로 발급하되, 중복 발급 방지와 동시성 제어를 보장한다.

---

🛠 **설계**  

**Redis + Redisson 분산락**  
- 쿠폰별 락(`lock:coupon:{couponId}`)을 사용하여 다중 서버 환경에서도 동시성 문제 방지.  

**캐시 기반 선착순 제어**  
- 쿠폰 재고(`coupon:remain:{couponId}`)를 Redis에 저장하고 `DECR` 연산으로 원자적 감소 처리.  
- DB보다 Redis가 훨씬 빠르므로 트래픽 집중 시에도 안정적 처리 가능.  

**DB 트랜잭션**  
- 실제 발급 내역은 DB에 저장.  
- 실패/롤백 시 캐시 복구(`INCR`)를 통해 데이터 불일치 해결.  

---

✅ **회고**  

**장점**  
- Redis 원자 연산을 활용하여 성능과 동시성 보장.  
- Redisson 분산락을 이용해 다중 서버 환경에서도 안전하게 동작.  
- DB 롤백 시 캐시 복구 처리까지 고려해 일관성 확보.  

**한계/개선점**  
- 락 점유 시간이 길면 다른 사용자 대기 → 성능 저하 가능.  
- `tryLock` 시간/임계 구간 최적화 필요.  
- 트래픽 폭주 상황에서는 비동기 큐(Kafka, RabbitMQ)를 통한 쿠폰 발급 요청 적재 후 순차 처리도 고려 가능.  

---

# 📌 최종 느낀 점  

이번 과제를 통해 Redis의 다양한 활용법(ZSet 기반 랭킹, 분산락, 캐시 원자 연산)을 실제 시나리오에 적용해볼 수 있었다.  

- 랭킹 시스템은 조회 성능 최적화,  
- 선착순 쿠폰 발급은 동시성 문제 해결이라는 실질적인 과제를 다뤘다.  

다만 실무 수준에서는 **트래픽 폭주 시 안정적인 처리 전략(비동기 큐, 배치 선반영, TTL 관리 등)**이 추가로 필요하다는 점을 느꼈다.
