## 1. 배경

현 시스템은 이커머스 플랫폼의 주문 및 사용자 잔액 관리 기능을 제공한다.
사용자 잔액 정보와 주문 상세 정보는 조회 빈도가 높고, 데이터의 변경 주기가 상대적으로 길어 DB에 직접 접근할 경우 시스템 부하 및 응답 지연이 발생할 수 있다.

예를 들어,
사용자 잔액은 결제나 충전 시 변경되지만, 대부분의 조회 요청은 읽기 전용이다.
주문 정보는 생성 이후 변경이 거의 없으므로 캐싱을 통한 성능 최적화가 가능하다.
이에 따라 Redis를 활용한 캐싱 전략을 도입하여, DB 부하를 줄이고 요청 처리 속도를 향상시키고자 한다.

## 2. 문제점
매 요청마다 DB를 직접 조회 → 응답 지연 증가 및 DB 부하 가중
데이터 변경 주기가 긴 리소스에 대한 비효율적 처리
특정 구간에서 반복적으로 동일한 데이터를 조회하는 상황 발생

## 3. 캐싱 전략 선정

3.1 사용자 잔액 조회
변경 주기: 잦음 (충전, 결제 시 변동)
전략: Write-Through + 짧은 TTL
충전/차감 시 DB와 캐시에 동시에 갱신
조회 시 Look-Aside 방식으로 캐시 우선 조회
TTL: 30초 → 데이터 불일치 가능성을 줄이고 최신성을 유지

3.2 주문 정보 조회
변경 주기: 매우 드묾 (주문 생성 후 거의 변경 없음)
전략: Look-Aside + 긴 TTL
최초 조회 시 DB에서 가져와 캐시에 저장
이후 요청은 캐시에서 즉시 반환
TTL: 1시간 → 생성된 주문은 변경 가능성이 낮아 긴 TTL 허용

## 4. 시나리오 적용
4.1 사용자 잔액 조회 (UserService)
``` java
public BalanceResponseDto getUserBalance(Long userId) throws Exception {
    String key = "balance:" + userId;

    // 1. 캐시 조회
    BigDecimal cached = (BigDecimal) redisTemplate.opsForValue().get(key);
    if (cached != null) return new BalanceResponseDto(cached);

    // 2. DB 조회
    UserEntity userEntity = userRepository.findById(userId)
        .orElseThrow(() -> new Exception("사용자를 찾을 수 없습니다."));

    // 3. 캐시 저장 (TTL 30초)
    redisTemplate.opsForValue().set(key, userEntity.getBalance(), Duration.ofSeconds(30));
    return new BalanceResponseDto(userEntity.getBalance());
}
```
충전(chargeBalance), 차감(deductBalance) 시 DB 저장과 동시에 캐시도 갱신 → Write-Through 적용

4.2 주문 조회 (OrderService)
``` java
public OrderResponseDto getOrderInfo(Long orderId) {
    String cacheKey = "order:" + orderId;

    // 1. 캐시 조회
    OrderResponseDto cachedOrder = redisTemplate.opsForValue().get(cacheKey);
    if (cachedOrder != null) return cachedOrder;

    // 2. DB 조회
    Optional<OrderEntity> order = orderRepository.getOrderInfo(orderId);
    if(order.isPresent()) {
        OrderResponseDto dto = new OrderResponseDto(...);

        // 3. 캐시 저장 (TTL 1시간)
        redisTemplate.opsForValue().set(cacheKey, dto, Duration.ofHours(1));
        return dto;
    }
    return null;
}
```
Look-Aside 전략 적용 → 캐시 미스 시 DB 조회 후 캐시에 저장

## 5.한계점 및 개선 방향
데이터 일관성: TTL 동안 데이터 변경이 캐시에 반영되지 않을 수 있음 → 캐시 무효화 정책 강화 필요
캐시 장애 시: Redis 장애 발생 시 DB fallback 동작 필요
TTL 최적화: 데이터 변경 주기 분석 기반으로 TTL 세밀하게 조정
분산 환경 고려: 다중 인스턴스 환경에서는 캐시 동기화 정책 필요
